{"meta":{"exported_on":1407780247284,"version":"002"},"data":{"posts":[{"id":1,"uuid":"299a8e98-74bc-4e08-a8d5-abd2fa595598","title":"Camera Distortion Calibration with SimpleCV","slug":"simplecv-calibration","markdown":"### Fixing Camera Distortion with SimpleCV in python. ###\n\nLast week I had to process a video feed from a 640x480 camera. \n\nThe camera however has a fish-eye lens that distorts the image and screws up the feed processing algorithms. In order to fix this I decided to apply an undistorting algorithm in Python (using the SimpleCV framework).\n\nIn order to do that you can do the following:\n\n1. Download and print off a [checkboard](http://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Checkerboard_pattern.svg/220px-Checkerboard_pattern.svg.png) pattern.\n2. Download [this](https://gist.github.com/atanasbozhkov/6985275) Python script.\n3. Run the script and follow the instructions.\n\nThe script will produce a matrix with the correction parameters. You can then import the calibration details into SimpleCV.\n\nHave fun waving that board in front of the camera.","html":"<h3 id=\"fixingcameradistortionwithsimplecvinpython\">Fixing Camera Distortion with SimpleCV in python.</h3>\n\n<p>Last week I had to process a video feed from a 640x480 camera. </p>\n\n<p>The camera however has a fish-eye lens that distorts the image and screws up the feed processing algorithms. In order to fix this I decided to apply an undistorting algorithm in Python (using the SimpleCV framework).</p>\n\n<p>In order to do that you can do the following:</p>\n\n<ol>\n<li>Download and print off a <a href=\"http://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Checkerboard_pattern.svg/220px-Checkerboard_pattern.svg.png\">checkboard</a> pattern.  </li>\n<li>Download <a href=\"https://gist.github.com/atanasbozhkov/6985275\">this</a> Python script.  </li>\n<li>Run the script and follow the instructions.</li>\n</ol>\n\n<p>The script will produce a matrix with the correction parameters. You can then import the calibration details into SimpleCV.</p>\n\n<p>Have fun waving that board in front of the camera.</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1381772261009,"created_by":1,"updated_at":1381801879073,"updated_by":1,"published_at":1381772261047,"published_by":1},{"id":2,"uuid":"b4bcd21b-3e43-411b-8a13-9bfd0382b31e","title":"Ghost Blog Update script","slug":"ghost-blog-update-script","markdown":"Last night Ghost v0.3.3 was released.\nI read through the update procedure and it seems that for now it will be manual.\n\nThis is why I created a simple bash script that should update Ghost to v0.3.3. Tested on OS X and Ubuntu.\n\nHere's my update procedure:\n\n**Diclaimer**: I am not responsible for any damage to your website/blog. Use it at your own discretion.\n\n1. Stop your Ghost server.\n2. Download the [update](https://gist.github.com/atanasbozhkov/7042919) script\n2.1 (optional) The script requires unzip and tar utilities so install them if you don't have them. (Google is your friend)\n3. Run the script by issuing `bash update.sh {path/to/ghost/} {backup_name.tar.gz}`\nI ran mine with:\n`bash update.sh /home/ghost/ backup.tar.gz`\n4. Your ghost installation should now be updated to v0.3.3. Don't forget to run your server again!\n\n\nI am planning to update the script with the upcoming releases. If you feel like making any improvements to it - feel free to to do it.\n\nHappy updating!","html":"<p>Last night Ghost v0.3.3 was released. <br />\nI read through the update procedure and it seems that for now it will be manual.</p>\n\n<p>This is why I created a simple bash script that should update Ghost to v0.3.3. Tested on OS X and Ubuntu.</p>\n\n<p>Here's my update procedure:</p>\n\n<p><strong>Diclaimer</strong>: I am not responsible for any damage to your website/blog. Use it at your own discretion.</p>\n\n<ol>\n<li>Stop your Ghost server.  </li>\n<li>Download the <a href=\"https://gist.github.com/atanasbozhkov/7042919\">update</a> script <br />\n2.1 (optional) The script requires unzip and tar utilities so install them if you don't have them. (Google is your friend)  </li>\n<li>Run the script by issuing <code>bash update.sh {path/to/ghost/} {backup_name.tar.gz}</code> <br />\nI ran mine with: <br />\n<code>bash update.sh /home/ghost/ backup.tar.gz</code></li>\n<li>Your ghost installation should now be updated to v0.3.3. Don't forget to run your server again!</li>\n</ol>\n\n<p>I am planning to update the script with the upcoming releases. If you feel like making any improvements to it - feel free to to do it.</p>\n\n<p>Happy updating!</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1382109224899,"created_by":1,"updated_at":1382109319986,"updated_by":1,"published_at":1382109224931,"published_by":1},{"id":3,"uuid":"8e7072c8-acad-4337-a584-66d52799d096","title":"My Top Sublime Text 3 Packages and Hacks","slug":"my-top-sublime-text-3-packages-and-hacks","markdown":"Here is my list for my top ST3 Packages and productivity hacks.\n\n### Packages ###\n\n1. Learn the shortcuts.\n\n\tI can't stress this one enough. One of the best things you can do in order to boost your productivity is to learn the shorcuts. \nYanking and moving lines around. Finding functions and invoking built-in functions - shortcuts will speed up everything.\n\n\tBest way to learn them is from this [book](https://leanpub.com/sublime-productivity). You can set the price yourself with a minumim of just £19. You can also get a [free sample](https://leanpub.com/sublime-productivity).\n\n2. SFTP\nOne of the best plug-ins if you're working on a remote host. The plugin is from the developer behind ST itself. It is paid but you can get it for free, but it's going to keep bugging you until you pay for it (fair enough I guess).\n\n3. Sublime Code Intel\nThis one is a **must**. Autocomleption is a feature of all respected IDEs. ST3 is surprisingly lacking in this aspect. Never the less SublimeCodeIntel promises to fix that, and does a great job keeping to the promise.\n\n4. Alignment\n\n\nHow ugly does that look?\n\n\t\tvar firstName = 'Brad';\n        var lastName = 'Pitt';\n        var age = 38;\n     \nSee anything? No?\nLook at these unaligned equal signs. **JUST LOOK AT THEM.**\n     Alignment is a plugin for programmers like me suffering from a minor form of OCD. It provides a handy shortcut for aligning all your variable declarations.\n     \n     var firstName = 'Brad';\n     var lastName  = 'Pitt';\n     var age       =  38;\n     \n   Better, no?\n   \n### Hacks ###","html":"<p>Here is my list for my top ST3 Packages and productivity hacks.</p>\n\n<h3 id=\"packages\">Packages</h3>\n\n<ol>\n<li><p>Learn the shortcuts.</p>\n\n<p>I can't stress this one enough. One of the best things you can do in order to boost your productivity is to learn the shorcuts. \nYanking and moving lines around. Finding functions and invoking built-in functions - shortcuts will speed up everything.</p>\n\n<p>Best way to learn them is from this <a href=\"https://leanpub.com/sublime-productivity\">book</a>. You can set the price yourself with a minumim of just £19. You can also get a <a href=\"https://leanpub.com/sublime-productivity\">free sample</a>.</p></li>\n<li><p>SFTP <br />\nOne of the best plug-ins if you're working on a remote host. The plugin is from the developer behind ST itself. It is paid but you can get it for free, but it's going to keep bugging you until you pay for it (fair enough I guess).</p></li>\n<li><p>Sublime Code Intel <br />\nThis one is a <strong>must</strong>. Autocomleption is a feature of all respected IDEs. ST3 is surprisingly lacking in this aspect. Never the less SublimeCodeIntel promises to fix that, and does a great job keeping to the promise.</p></li>\n<li><p>Alignment</p></li>\n</ol>\n\n<p>How ugly does that look?</p>\n\n<pre><code>    var firstName = 'Brad';\n    var lastName = 'Pitt';\n    var age = 38;\n</code></pre>\n\n<p>See anything? No? <br />\nLook at these unaligned equal signs. <strong>JUST LOOK AT THEM.</strong> <br />\n     Alignment is a plugin for programmers like me suffering from a minor form of OCD. It provides a handy shortcut for aligning all your variable declarations.</p>\n\n<pre><code> var firstName = 'Brad';\n var lastName  = 'Pitt';\n var age       =  38;\n</code></pre>\n\n<p>Better, no?</p>\n\n<h3 id=\"hacks\">Hacks</h3>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1382403362934,"created_by":1,"updated_at":1382403362934,"updated_by":1,"published_at":null,"published_by":null},{"id":4,"uuid":"6f411931-c4fa-4fd9-bd6c-b5a94c26fd2b","title":"A Distributed Hash Table in pure JavaScript","slug":"a-distributed-hash-table-in-pure-javascript","markdown":"I am working on a University project which involves a P2P connection between web browsers.\n\nThe framework that I decided to go with was **[PeerJS](http://peerjs.com)**\n\nPeerJS is wonderful. It is really easy and straightforward to use and it has all the functionality that one can ask for. It does have some bugs and limitations, but so far I haven't seen anything that cannot be bypassed with a simple workaraound.\n\nOf course - using P2P in most cases implies that there should be a **DHT** governing what information is held by which peers. \n\nUnfortunately the only things that I found available were implementaions in NodeJS. Since that's not what I wanted I decided to implement  a DHT in pure JS for in browser usage.\n\nI found [Implementing  Kademlia DHT in Go](http://blog.notdot.net/2009/11/Implementing-a-DHT-in-Go-part-1) by Nick Johnson very helpfull in this undertaking,  I **strongly** recommend you read it because his explenations are quite good. Even though his code was written in GO and most of the logic and methods had to be rewritten in order to work in javascript, the main logic is still very similar.\nNick has based his implementation on the [XLattice's Protocol Specification](http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html) which was an excellent cheat-sheat during most of the programming.\n\nI'll asume that you've already read the protocol and have at least some vague idea of how Kademlia does what it does.\nSo - let's go ahead and dive into the code.\n\nFirst we'll need to set up some functions that will later come in useful.\n\n\t//Used to move an element from one index to another inside of an array\n    //Array.move Prototype\n\tArray.prototype.move = function (old_index, new_index) {\n    if (new_index >= this.length) {\n        var k = new_index - this.length;\n        while ((k--) + 1) {\n            this.push(undefined);\n        }\n    }\n    this.splice(new_index, 0, this.splice(old_index, 1)[0]);\n    return this; // for testing purposes\n\t};\n\n\t//Function taken from crypto.js\n    //Converts a hex string (like SHA1) to an array of bytes\n\tfunction hexToBytes(hex) {\n                for (var bytes = [], c = 0; c < hex.length; c += 2)\n                        bytes.push(parseInt(hex.substr(c, 2), 16));\n                return bytes;\n\t}\n\n\t//Function taken from crypto.js\n    //Converts an array of bytes to a hex string\n\tfunction bytesToHex(bytes) {\n                for (var hex = [], i = 0; i < bytes.length; i++) {\n                        hex.push((bytes[i] >>> 4).toString(16));\n                        hex.push((bytes[i] & 0xF).toString(16));\n                }\n                return hex.join(\"\");\n\t}\n   The **Array.Move()** function will come in handy, when we have to reorder nodes inside of an array. \n The **bytesToHex()** and **hexToBytes()** functions are used for the ID's of the nodes.\n Every node has a 160bit pseudo-random ID  ( and since one hex character can only represent 16 different values, i.e. 4 bits. 16 = 2<sup>4</sup>),   converting those 160bits into hex will give us a string of length 40.\n   \n   **Example:**\n\n\t> bytes\n    [48, 79, 186, 180, 86, 41, 129, 184, 130, 11, 233, 243, 139, 178, 82, 104, 197, 116, 222, 15]\n    > bytesToHex(bytes)\n\t\"304fbab4562981b8820be9f38bb25268c574de0f\"\n    \n    \n   \n Now that we have the basics we need a constant and two functions. One for creating nodeIDs from a hex string and one for generating random ones.\n \n \t//Define constants\n\tconst IdLength = 20;\n  \tfunction NewNodeID(string){\n    \t  decoded = hexToBytes(string); //conv to byte array\n      \tvar ret = []\n      \tfor (var i = 0; i< IdLength; i++) {\n          ret[i] = decoded[i] //Decode each digit\n      };\n  \n      return ret;\n  \t}\n  \n  \tfunction NewRandomNodeID(){\n        var ret = [];\n        for (var i = 0; i < IdLength; i++) {\n            ret[i] = Math.floor((Math.random()*256)); //between 1 and 256\n        };\n        return ret;\n\t  }\n\nNow that we have these layed out we can create new random NodeIDs by just calling: `NewRandomNodeID()`\n\nNext - we need to be able to compare to nodeIDs\n\n\tfunction Equals(node1, node2){\n      for (var i = 0; i< IdLength; i++) {\n          if (node1[i] != node2[i]) {\n              return false;\n          };\n      }\n     \treturn true;\n    }\n\n\tfunction Less (node1, node2) {\n      for (var i = 0; i < IdLength; i++){\n          if (node1[i] != node2[i]){\n              return node1[i] < node2[i];\n          }\n      }\n      return false;\n     }\n  \n      function Xor(node1,node2){\n        var ret = [];\n        for(var i = 0; i < IdLength; i++){\n            ret[i] = node1[i]^node2[i];\n        }\n        return ret;\n\t}\n\nThe most notable one here is the **Xor()** function. Kademlia uses it as a distance measure in order to be able to determine which node has what.\n\nAs Nick best puts it - \"_the number of the bucket a given node **should be placed in is determined by the number of leading 0 bits in the XOR of our node ID with the target node** ID, which makes for easy implementation._\"\n\nImplementing this is quite easy infact, even though at first it looks cryptic:\n\n    //Number of leading zeros\n    function PrefixLen(node){\n        for(var i = 0; i < IdLength; i++){\n            for(var j = 0; j<8; j++){\n                if ((node[i] >> 7-j & 0x1) != 0){\n                    return i * 8 + j;\n                }\n            }\n        }\n        return IdLength * 8 - 1;\n    }\n   \n   \nFor the implemention of the Routing Table that each node holds, we have the following:   \n   \n     function NewRoutingTable(node){\n      //Define the routing table struct;\n      var routingTable = {\n          'buckets':[],\n          node:node\n      };\n  \n      //Create the buckets\n      for(var i=0; i < IdLength * 8; i++){\n          routingTable.buckets[i] = []\n      }\n      //and the node\n      routingTable.node = node;\n      return routingTable;\n\t  }\n      \n\nA simple structure that creates a placeholder for the node's own ID and allocates the arrays for the buckets as per the protocol.\n\nNow we need a function that takes will update a routing table of a node with the details of a recently connected node. This function will be called when connection is made between two nodes.\n\n\n\tfunction Update(node, table)\n\t{\n\tvar found = false;\n\tvar prefix_len = PrefixLen(node);\n\tbucket = table.buckets[prefix_len];\n\t//First check wether the node is already contained within the bucket.\n\ttable.buckets[prefix_len].map(function(x){\n\t\tif (Equals(x, node))\n\t\t{\n\t\t\tvar pos = table.buckets[prefix_len].indexOf(x);\n\t\t\ttable.buckets[prefix_len].move(pos,0);\n\t\t\tfound = true;\n\t\t}});\n\tif (found == false){\n\t\t//Now - if it's not in the bucket - check wether the bucket is full.\n\n\t\tif(table.buckets[prefix_len].length < BucketSize){\n\t\t\ttable.buckets[prefix_len].push(node);\n\t\t    // TODO: Handle insertion when the list is full by evicting old elements if\n\t\t    // they don't respond to a ping.\n      }\n      }\n\n\t}\n    \n   So far - so good. We also need to be able to find the closest peers to a particular node. Nick has called this a distance \"vector\". I shall stick with this naming.\n   \n     function copyToVector(bucket, target, vector){\n      for (var i = 0; i < bucket.length; i++) {\n          console.log('copyToVector: The bucket is:'+bucket[i]);\n          console.log('copyToVector: The distance is: '+Xor(bucket[i], target))\n          vector[i] = {node:bucket[i],distance:Xor(bucket[i], target)};\n      };\n      return vector;\n  \t}\n  \n  \tfunction FindClosest (node,count, table){\n        var vector = [];\n        bucket_num = PrefixLen(Xor(node, table.node));\n        bucket = table.buckets[bucket_num];\n        copyToVector(bucket, node, vector);\n        for (var i = 1; (bucket_num - i >= 0 || bucket_num + i < IdLength * 8) && vector.length < count; i++) {\n            if (bucket_num - i >= 0) {\n                bucket = table.buckets[bucket_num - i];\n                copyToVector(bucket, node, vector);\n            };\n            if (bucket_num < IdLength * 8) {\n                bucket = table.buckets[bucket_num + i];\n                copyToVector(bucket, node, vector);\n            };\n        };\n        vector.sort(function(a,b){bytesToHex(a.distance) - bytesToHex(b.distance)});\n        return vector;\n \t }\n     \n Of course we should have a way of testing all this. I've used these two functions to test the main functinality.\n \n \tfunction testUpdate(){\n      var mynode = NewRandomNodeID();\n      var tab = NewRoutingTable(mynode);\n      for (var i = 0; i < 100; i++) {\n          Update(NewRandomNodeID(), tab);\n      };\n      return tab;\n\t}\n\n\tfunction testDistance(){\n      var tab = testUpdate();\n      var findMe = NewRandomNodeID()\n      var vecD = FindClosest(findMe, BucketSize, tab);\n      return vecD;\n\t}\n \n This constitues for a good skeleton of DHT. There is still a lot of functionallity to be added in order to be able to call this \"ready for production\", but for now development is going well.\n   \n \n   \n When the final code is ready I will upload it to GitHub and link it here.\nAgain big shoutout to Nick Johnson for his comprehehnsive guide. \nAny comments and critisim are more than welcome.","html":"<p>I am working on a University project which involves a P2P connection between web browsers.</p>\n\n<p>The framework that I decided to go with was <strong><a href=\"http://peerjs.com\">PeerJS</a></strong></p>\n\n<p>PeerJS is wonderful. It is really easy and straightforward to use and it has all the functionality that one can ask for. It does have some bugs and limitations, but so far I haven't seen anything that cannot be bypassed with a simple workaraound.</p>\n\n<p>Of course - using P2P in most cases implies that there should be a <strong>DHT</strong> governing what information is held by which peers. </p>\n\n<p>Unfortunately the only things that I found available were implementaions in NodeJS. Since that's not what I wanted I decided to implement  a DHT in pure JS for in browser usage.</p>\n\n<p>I found <a href=\"http://blog.notdot.net/2009/11/Implementing-a-DHT-in-Go-part-1\">Implementing  Kademlia DHT in Go</a> by Nick Johnson very helpfull in this undertaking,  I <strong>strongly</strong> recommend you read it because his explenations are quite good. Even though his code was written in GO and most of the logic and methods had to be rewritten in order to work in javascript, the main logic is still very similar. <br />\nNick has based his implementation on the <a href=\"http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html\">XLattice's Protocol Specification</a> which was an excellent cheat-sheat during most of the programming.</p>\n\n<p>I'll asume that you've already read the protocol and have at least some vague idea of how Kademlia does what it does. <br />\nSo - let's go ahead and dive into the code.</p>\n\n<p>First we'll need to set up some functions that will later come in useful.</p>\n\n<pre><code>//Used to move an element from one index to another inside of an array\n//Array.move Prototype\nArray.prototype.move = function (old_index, new_index) {\nif (new_index &gt;= this.length) {\n    var k = new_index - this.length;\n    while ((k--) + 1) {\n        this.push(undefined);\n    }\n}\nthis.splice(new_index, 0, this.splice(old_index, 1)[0]);\nreturn this; // for testing purposes\n};\n\n//Function taken from crypto.js\n//Converts a hex string (like SHA1) to an array of bytes\nfunction hexToBytes(hex) {\n            for (var bytes = [], c = 0; c &lt; hex.length; c += 2)\n                    bytes.push(parseInt(hex.substr(c, 2), 16));\n            return bytes;\n}\n\n//Function taken from crypto.js\n//Converts an array of bytes to a hex string\nfunction bytesToHex(bytes) {\n            for (var hex = [], i = 0; i &lt; bytes.length; i++) {\n                    hex.push((bytes[i] &gt;&gt;&gt; 4).toString(16));\n                    hex.push((bytes[i] &amp; 0xF).toString(16));\n            }\n            return hex.join(\"\");\n}\n</code></pre>\n\n<p>The <strong>Array.Move()</strong> function will come in handy, when we have to reorder nodes inside of an array. \n The <strong>bytesToHex()</strong> and <strong>hexToBytes()</strong> functions are used for the ID's of the nodes.\n Every node has a 160bit pseudo-random ID  ( and since one hex character can only represent 16 different values, i.e. 4 bits. 16 = 2<sup>4</sup>),   converting those 160bits into hex will give us a string of length 40.</p>\n\n<p><strong>Example:</strong></p>\n\n<pre><code>&gt; bytes\n[48, 79, 186, 180, 86, 41, 129, 184, 130, 11, 233, 243, 139, 178, 82, 104, 197, 116, 222, 15]\n&gt; bytesToHex(bytes)\n\"304fbab4562981b8820be9f38bb25268c574de0f\"\n</code></pre>\n\n<p>Now that we have the basics we need a constant and two functions. One for creating nodeIDs from a hex string and one for generating random ones.</p>\n\n<pre><code> //Define constants\nconst IdLength = 20;\n  function NewNodeID(string){\n      decoded = hexToBytes(string); //conv to byte array\n      var ret = []\n      for (var i = 0; i&lt; IdLength; i++) {\n      ret[i] = decoded[i] //Decode each digit\n  };\n\n  return ret;\n  }\n\n  function NewRandomNodeID(){\n    var ret = [];\n    for (var i = 0; i &lt; IdLength; i++) {\n        ret[i] = Math.floor((Math.random()*256)); //between 1 and 256\n    };\n    return ret;\n  }\n</code></pre>\n\n<p>Now that we have these layed out we can create new random NodeIDs by just calling: <code>NewRandomNodeID()</code></p>\n\n<p>Next - we need to be able to compare to nodeIDs</p>\n\n<pre><code>function Equals(node1, node2){\n  for (var i = 0; i&lt; IdLength; i++) {\n      if (node1[i] != node2[i]) {\n          return false;\n      };\n  }\n     return true;\n}\n\nfunction Less (node1, node2) {\n  for (var i = 0; i &lt; IdLength; i++){\n      if (node1[i] != node2[i]){\n          return node1[i] &lt; node2[i];\n      }\n  }\n  return false;\n }\n\n  function Xor(node1,node2){\n    var ret = [];\n    for(var i = 0; i &lt; IdLength; i++){\n        ret[i] = node1[i]^node2[i];\n    }\n    return ret;\n}\n</code></pre>\n\n<p>The most notable one here is the <strong>Xor()</strong> function. Kademlia uses it as a distance measure in order to be able to determine which node has what.</p>\n\n<p>As Nick best puts it - \"<em>the number of the bucket a given node <strong>should be placed in is determined by the number of leading 0 bits in the XOR of our node ID with the target node</strong> ID, which makes for easy implementation.</em>\"</p>\n\n<p>Implementing this is quite easy infact, even though at first it looks cryptic:</p>\n\n<pre><code>//Number of leading zeros\nfunction PrefixLen(node){\n    for(var i = 0; i &lt; IdLength; i++){\n        for(var j = 0; j&lt;8; j++){\n            if ((node[i] &gt;&gt; 7-j &amp; 0x1) != 0){\n                return i * 8 + j;\n            }\n        }\n    }\n    return IdLength * 8 - 1;\n}\n</code></pre>\n\n<p>For the implemention of the Routing Table that each node holds, we have the following:   </p>\n\n<pre><code> function NewRoutingTable(node){\n  //Define the routing table struct;\n  var routingTable = {\n      'buckets':[],\n      node:node\n  };\n\n  //Create the buckets\n  for(var i=0; i &lt; IdLength * 8; i++){\n      routingTable.buckets[i] = []\n  }\n  //and the node\n  routingTable.node = node;\n  return routingTable;\n  }\n</code></pre>\n\n<p>A simple structure that creates a placeholder for the node's own ID and allocates the arrays for the buckets as per the protocol.</p>\n\n<p>Now we need a function that takes will update a routing table of a node with the details of a recently connected node. This function will be called when connection is made between two nodes.</p>\n\n<pre><code>function Update(node, table)\n{\nvar found = false;\nvar prefix_len = PrefixLen(node);\nbucket = table.buckets[prefix_len];\n//First check wether the node is already contained within the bucket.\ntable.buckets[prefix_len].map(function(x){\n    if (Equals(x, node))\n    {\n        var pos = table.buckets[prefix_len].indexOf(x);\n        table.buckets[prefix_len].move(pos,0);\n        found = true;\n    }});\nif (found == false){\n    //Now - if it's not in the bucket - check wether the bucket is full.\n\n    if(table.buckets[prefix_len].length &lt; BucketSize){\n        table.buckets[prefix_len].push(node);\n        // TODO: Handle insertion when the list is full by evicting old elements if\n        // they don't respond to a ping.\n  }\n  }\n\n}\n</code></pre>\n\n<p>So far - so good. We also need to be able to find the closest peers to a particular node. Nick has called this a distance \"vector\". I shall stick with this naming.</p>\n\n<pre><code> function copyToVector(bucket, target, vector){\n  for (var i = 0; i &lt; bucket.length; i++) {\n      console.log('copyToVector: The bucket is:'+bucket[i]);\n      console.log('copyToVector: The distance is: '+Xor(bucket[i], target))\n      vector[i] = {node:bucket[i],distance:Xor(bucket[i], target)};\n  };\n  return vector;\n  }\n\n  function FindClosest (node,count, table){\n    var vector = [];\n    bucket_num = PrefixLen(Xor(node, table.node));\n    bucket = table.buckets[bucket_num];\n    copyToVector(bucket, node, vector);\n    for (var i = 1; (bucket_num - i &gt;= 0 || bucket_num + i &lt; IdLength * 8) &amp;&amp; vector.length &lt; count; i++) {\n        if (bucket_num - i &gt;= 0) {\n            bucket = table.buckets[bucket_num - i];\n            copyToVector(bucket, node, vector);\n        };\n        if (bucket_num &lt; IdLength * 8) {\n            bucket = table.buckets[bucket_num + i];\n            copyToVector(bucket, node, vector);\n        };\n    };\n    vector.sort(function(a,b){bytesToHex(a.distance) - bytesToHex(b.distance)});\n    return vector;\n  }\n</code></pre>\n\n<p>Of course we should have a way of testing all this. I've used these two functions to test the main functinality.</p>\n\n<pre><code> function testUpdate(){\n  var mynode = NewRandomNodeID();\n  var tab = NewRoutingTable(mynode);\n  for (var i = 0; i &lt; 100; i++) {\n      Update(NewRandomNodeID(), tab);\n  };\n  return tab;\n}\n\nfunction testDistance(){\n  var tab = testUpdate();\n  var findMe = NewRandomNodeID()\n  var vecD = FindClosest(findMe, BucketSize, tab);\n  return vecD;\n}\n</code></pre>\n\n<p>This constitues for a good skeleton of DHT. There is still a lot of functionallity to be added in order to be able to call this \"ready for production\", but for now development is going well.</p>\n\n<p>When the final code is ready I will upload it to GitHub and link it here.\nAgain big shoutout to Nick Johnson for his comprehehnsive guide. <br />\nAny comments and critisim are more than welcome.</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1390421491681,"created_by":1,"updated_at":1390955005078,"updated_by":1,"published_at":1390424142095,"published_by":1}],"users":[{"id":1,"uuid":"008b4dac-5808-4e48-9282-590c5ff0cec7","name":"Atanas Bozhkov","slug":"atanas-bozhkov","password":"$2a$10$S3Ut.AybDijgqr1Ln4LG7.JPMkqN3wusB2QHxxUiOStJC4YWVDnHW","email":"bozhkov.atanas@gmail.com","image":null,"cover":null,"bio":"","website":"","location":"London","accessibility":null,"status":"active","language":"en_US","meta_title":null,"meta_description":null,"last_login":null,"created_at":1381772465358,"created_by":1,"updated_at":1407606088186,"updated_by":1}],"roles":[{"id":1,"uuid":"c6fc5acd-a5a0-4ca1-8ece-4d9e770ffd55","name":"Administrator","description":"Administrators","created_at":1381772261190,"created_by":1,"updated_at":1381772261190,"updated_by":1},{"id":2,"uuid":"f0582170-c077-47eb-ad40-b259dee286f0","name":"Editor","description":"Editors","created_at":1381772261208,"created_by":1,"updated_at":1381772261208,"updated_by":1},{"id":3,"uuid":"58de80a6-376e-4191-bc32-e50cca3d2d30","name":"Author","description":"Authors","created_at":1381772261226,"created_by":1,"updated_at":1381772261226,"updated_by":1}],"roles_users":[{"id":1,"role_id":1,"user_id":1}],"permissions":[{"id":1,"uuid":"f58bce35-6b4b-40d7-b044-2db1e0dacef5","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":1381772261245,"created_by":1,"updated_at":1381772261245,"updated_by":1},{"id":2,"uuid":"4ae27fb0-d6b2-4a5a-b65a-8603126e2f70","name":"Remove posts","object_type":"post","action_type":"remove","object_id":null,"created_at":1381772261260,"created_by":1,"updated_at":1381772261260,"updated_by":1},{"id":3,"uuid":"e0234943-4610-496f-a977-e3a441efbe32","name":"Create posts","object_type":"post","action_type":"create","object_id":null,"created_at":1381772261290,"created_by":1,"updated_at":1381772261290,"updated_by":1}],"permissions_users":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3}],"settings":[{"id":1,"uuid":"00973740-b2b5-464b-9c2b-cf8748ea598f","key":"databaseVersion","value":"002","type":"core","created_at":1381772261344,"created_by":1,"updated_at":1381772261344,"updated_by":1},{"id":2,"uuid":"b4941d1b-3d30-4891-812a-38aad69f6dd6","key":"title","value":"Atanas Bozhkov","type":"blog","created_at":1381772261371,"created_by":1,"updated_at":1394153898192,"updated_by":1},{"id":3,"uuid":"2c76ab5d-ce9c-4a39-8ba3-bf2b9498b7c0","key":"description","value":"","type":"blog","created_at":1381772261372,"created_by":1,"updated_at":1394153898193,"updated_by":1},{"id":4,"uuid":"b343d467-09eb-413f-95a6-27b9983bed26","key":"email","value":"bozhkov.atanas@gmail.com","type":"blog","created_at":1381772261373,"created_by":1,"updated_at":1394153898195,"updated_by":1},{"id":5,"uuid":"ea17d252-48a5-443f-af3d-6381db354d38","key":"logo","value":"/content/images/2013/Nov/cricle_2.png","type":"blog","created_at":1381772261385,"created_by":1,"updated_at":1394153898197,"updated_by":1},{"id":6,"uuid":"3881185f-f5e3-4efe-9d96-1671b4b3fac5","key":"cover","value":"/content/images/2013/Nov/cover-1.jpg","type":"blog","created_at":1381772261385,"created_by":1,"updated_at":1394153898199,"updated_by":1},{"id":7,"uuid":"5ffb39ee-a505-4ae0-8db0-9dbe4e332e15","key":"defaultLang","value":"en_US","type":"blog","created_at":1381772261387,"created_by":1,"updated_at":1394153898200,"updated_by":1},{"id":8,"uuid":"a6ac2d5d-ad4d-4461-9fff-738f224bdb99","key":"postsPerPage","value":"6","type":"blog","created_at":1381772261387,"created_by":1,"updated_at":1394153898202,"updated_by":1},{"id":9,"uuid":"3f574a5b-083a-4921-ad17-56534794bf31","key":"forceI18n","value":"true","type":"blog","created_at":1381772261388,"created_by":1,"updated_at":1394153898203,"updated_by":1},{"id":10,"uuid":"622109be-deda-43e9-8598-a2012678feda","key":"activeTheme","value":"casper","type":"theme","created_at":1381772261388,"created_by":1,"updated_at":1394153898204,"updated_by":1},{"id":11,"uuid":"3feeaa62-a6ac-4dc7-8c18-ceb4d3620c61","key":"activePlugins","value":"[]","type":"plugin","created_at":1381772261389,"created_by":1,"updated_at":1381772261389,"updated_by":1},{"id":12,"uuid":"bee860eb-189b-44d0-a2af-c2eae4c17f09","key":"installedPlugins","value":"[]","type":"plugin","created_at":1381772261389,"created_by":1,"updated_at":1407543044724,"updated_by":1},{"id":13,"uuid":"cb7bc45d-5e9d-4860-9459-c9843fe0f9ce","key":"dbHash","value":"b8c6c97d-26a4-4bd7-b00b-63e0c9b2ac48","type":"core","created_at":1381772261652,"created_by":1,"updated_at":1381772261652,"updated_by":1},{"id":14,"uuid":"64b55aaa-c019-489a-a5e2-7e361d87c2a3","key":"nextUpdateCheck","value":"1407691868","type":"core","created_at":1391270399712,"created_by":1,"updated_at":1407606069549,"updated_by":1},{"id":15,"uuid":"8ac1b0bb-779d-4e5a-9855-bdb86c0967f4","key":"displayUpdateNotification","value":"0.4.2","type":"core","created_at":1391270399714,"created_by":1,"updated_at":1407606069552,"updated_by":1},{"id":16,"uuid":"39e19259-8ddc-4e63-ba35-915427c1a74e","key":"permalinks","value":"/:slug/","type":"blog","created_at":1391270399715,"created_by":1,"updated_at":1394153898205,"updated_by":1},{"id":17,"uuid":"0dddd3fc-ec63-495d-8fb3-e00487d5cef9","key":"activeApps","value":"[]","type":"app","created_at":1407543290037,"created_by":1,"updated_at":1407543290037,"updated_by":1},{"id":18,"uuid":"292e9792-7ede-4b73-856b-be3abaf73935","key":"installedApps","value":"[]","type":"app","created_at":1407543290039,"created_by":1,"updated_at":1407543318123,"updated_by":1}],"tags":[{"id":1,"uuid":"659a8f54-7b37-4e57-a642-217eefdadb50","name":"Getting Started","slug":"getting-started","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1381772261168,"created_by":1,"updated_at":1381772261168,"updated_by":1},{"id":2,"uuid":"c3ffd63d-d516-4304-916a-f21270f307c7","name":"SimpleCV","slug":"simplecv","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1381776806448,"created_by":1,"updated_at":1381776806448,"updated_by":1},{"id":3,"uuid":"36d1e3e8-4925-4320-885e-6124314a0b3d","name":"Camera","slug":"camera","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1381776806449,"created_by":1,"updated_at":1381776806449,"updated_by":1},{"id":4,"uuid":"2c35fa73-0f26-4167-aaad-a6a2ef7a169c","name":"Distortion","slug":"distortion","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1381776806449,"created_by":1,"updated_at":1381776806449,"updated_by":1},{"id":5,"uuid":"7528f54f-65c2-4a25-896d-0d7fb263e046","name":"Python","slug":"python","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1381776806450,"created_by":1,"updated_at":1381776806450,"updated_by":1},{"id":6,"uuid":"3607df2d-fffe-40d3-b7d8-df04b0fbcc49","name":"javasript","slug":"javasript","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1390421551725,"created_by":1,"updated_at":1390421551725,"updated_by":1},{"id":7,"uuid":"81c08b1b-516f-4a87-97b0-4831b7c8416f","name":"DHT","slug":"dht","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1390421551726,"created_by":1,"updated_at":1390421551726,"updated_by":1},{"id":8,"uuid":"0a014cbc-6e4f-4ea2-92a0-5f400a4f0b91","name":"distributed","slug":"distributed","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1390421551727,"created_by":1,"updated_at":1390421551727,"updated_by":1},{"id":9,"uuid":"44b86919-f0c0-4b7c-9735-bcc6b0681192","name":"hash","slug":"hash","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1390421551727,"created_by":1,"updated_at":1390421551727,"updated_by":1},{"id":10,"uuid":"e868246a-f381-4de0-ad18-8319f1a7aed1","name":"table","slug":"table","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1390421551728,"created_by":1,"updated_at":1390421551728,"updated_by":1},{"id":11,"uuid":"e84fea41-04f4-4aa5-88fe-56ad4e2cf976","name":"JS","slug":"js","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1390421551728,"created_by":1,"updated_at":1390421551728,"updated_by":1},{"id":12,"uuid":"8a77f2a9-1b71-4643-8577-f42e704b737b","name":"kademlia","slug":"kademlia","description":null,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1390421551728,"created_by":1,"updated_at":1390421551728,"updated_by":1}],"posts_tags":[{"id":2,"post_id":1,"tag_id":2},{"id":3,"post_id":1,"tag_id":3},{"id":4,"post_id":1,"tag_id":4},{"id":5,"post_id":1,"tag_id":5},{"id":6,"post_id":4,"tag_id":6},{"id":7,"post_id":4,"tag_id":7},{"id":8,"post_id":4,"tag_id":8},{"id":9,"post_id":4,"tag_id":9},{"id":10,"post_id":4,"tag_id":10},{"id":11,"post_id":4,"tag_id":11},{"id":12,"post_id":4,"tag_id":12}],"sessions":[{"id":"7yRDLOsNFThiKaZ39GGa02ID","expires":1407649289219,"sess":"{\"cookie\":{\"originalMaxAge\":43200000,\"expires\":\"2014-08-10T05:41:29.219Z\",\"httpOnly\":true,\"path\":\"/ghost/\"},\"user\":1,\"_csrfSecret\":\"nToEgjsr8Qe9Vmg72g7jEBPA\"}"}]}}